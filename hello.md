# Java内存模型和JVM内存模型:
  Java 内存模型规定所有的变量都是存在主存中，每个线程都有自己的工作内存。线程堆变量的操作必须在工作内存进行。不能直接在堆内存进行操作。并且每个线程不能访问其他线程的工作内存。  
  ## JVM内存模型：  
    *虚拟机栈：用来存放局部变量、堆区对象的引用和常量池的引用。但对象本身不放在栈中，而是存放在堆（new出来的对象）或者常量池中(对象可*能在常量池中，字符串常量对象存放在常量池中)。  
    *方法区：存放类的信息；这个区包含常量池（常量池用来放基本类型变量和字符串类型变量）。此部分可以回收；方法区可以放用static修饰的变量，但此部分不能回收，因为方法区也就持久代。基本不参与垃圾回收。  
    *堆：存放一些new出的对象（包含成员变量）和数组。  
## Java8之前，常量池是存放在堆中的，常量池就相当于在永久代中。所以永久代存放在堆中。  
## Java8之后，取消了整个永久代区域，取而代之的是元空间。常量池就不存放在堆中，而是在方法去里面，与堆栈是并列关系。  


# Java 内存泄漏和内存溢出：
内存溢出Out of memory 。是指程序在申请内存后，没有足够的内存空间供其使用，出现Out of memory；  
内存泄漏 memory leak，是指程序在申请后，无法释放已申请的内存空间，一次内存泄漏可以忽略，但内存泄漏堆积后果很严重，无论多少内存，迟早会被沾光。  
例如：静态集合类引起的内存泄漏，  
像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。  
Static Vector v = new Vector(10);for (int i = 1; i<100; i++)  
{  
Object o = new Object();  
v.add(o);  
o = null;  
}//  
在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。  