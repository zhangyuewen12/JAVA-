## HashMap 为什么使用 & 与运算代替模运算？   
HashMap 设计初始大小为 16，是为了取模时能够使用速度更快的与运算   
```
例如，十进制的 100，要对 8 取余，正常操作是让 100 多次除以 8，最后得到 4，   
在除 8 过程中事实上已经将 100 转换成 8 进制数了（144），可以看到对 8 取余的余数即为 8 进制下的个位数。   

计算机中以 2 进制存储，因此要将取余运算转变到二进制级别的运算，唯一的条件是：   
对 n 取余，n 进制的每一位能对应二进制中整数位，即 8 进制中每一位对应二进制中 3 位。   
8 进制：144   
2 进制：001 100 100   
因此 HashMap 设计初始大小为 16，是为了取模时能够使用速度更快的与运算   
抽象成计算式：X % 2n = X & (2n - 1)
```

##  HashMap 的容量为什么建议是 2的幂次方？   
最大限度的利用 hash 值，并更好的散列,得到更好的散列结果。
````
假设我们的数组长度是10，还是上面的公式：   
1010 & 101010100101001001000 结果：1000 = 8   
1010 & 101000101101001001001 结果：1000 = 8   
1010 & 101010101101101001010 结果： 1010 = 10   
1010 & 101100100111001101100 结果： 1000 = 8   

这种散列结果，会导致这些不同的key值全部进入到相同的插槽中，形成链表，性能急剧下降。   

所以说，我们一定要保证 & 中的二进制位全为 1，才能最大限度的利用 hash 值，并更好的散列，只有全是1 ，才能有更多 的散列结果。如果是 1010，有的散列结果是永远都不会出现的，比如 0111，0101，1111，1110…，只要 & 之前的数有 0， 对应的 1 肯定就不会出现（因为只有都是1才会为1）。大大限制了散列的范围。

`````